# -*- coding: utf-8 -*-
from datetime import datetime, timedelta
from num2words import num2words
from odoo import models, fields, api, _
from odoo.tools import float_compare
from odoo.exceptions import ValidationError
import base64,logging
_logger = logging.getLogger(__name__)


class SaleOrder(models.Model):
    _inherit = 'sale.order'

    def _default_so_style(self):
        return self.env.user.company_id.df_style
    
    @api.depends("journal_id")
    def _compute_partner_tag(self):
        for order in self:
            if self.partner_id and self.partner_id.category_id:
                self.partner_tag_id = self.partner_id.category_id[0]
            else:
                self.partner_tag_id = False

    name = fields.Char(string='Order Reference', required=True, copy=False, readonly=False, states={'draft': [('readonly', False)]}, index=True, default=lambda self: _('New'),tracking=True,)
    revised_custom_ids = fields.One2many('quotation.history', 'sale_order_id', string='Revised', copy=False,)
    custom_counter = fields.Integer(default=0, copy=False,)
    custom_store_name = fields.Char(string="Store value", copy=False)
    parent_id = fields.Many2one(string='Parent Order', comodel_name='sale.order', ondelete='restrict',)
    partner_tag_id = fields.Many2one(string='Partner Tag', comodel_name='res.partner.category', compute='_compute_partner_tag' , store=True,)
    child_ids = fields.One2many(string='Children Order', comodel_name='sale.order', inverse_name='parent_id',)
    sale_order_count = fields.Integer(related='partner_id.sale_order_count', string='Sale Order Count')
    # style = fields.Many2one('report.template.settings', 'Quote/Order Style', default= _default_so_style,
    #     help="Select Style to use when printing the Sales Order or Quote")
    project_title = fields.Char('Title', help="The title of your customer project or work you are doing for your customer")
    amount_words = fields.Char('Amount in Words:', help="The total amount in words is automatically generated by the system", compute='_compute_num2words')
    pricelist_id = fields.Many2one('product.pricelist', string='Pricelist', check_company=True,  # Unrequired company
        required=True, readonly=True, domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]", tracking=True,
        help="If you change the pricelist, only newly added lines will be affected.")
    commitment_date = fields.Datetime('Delivery Date', copy=False, states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},# required=True,
        help="This is the delivery date promised to the customer. If set, the delivery order will be scheduled based on this date rather than product lead times.")
    state = fields.Selection([
        ('draft', 'Quotation'),
        ('sent', 'Quotation Sent'),
        ('sale', 'Sales Order'),
        ('confirm', 'Confirm'),
        ('done', 'Locked'),
        ('cancel', 'Cancelled'),
        ], string='Status', readonly=True, copy=False, index=True, tracking=3, default='draft')
    is_order_confirm = fields.Boolean(string='Is Order Confirm', default=False)
    journal_id = fields.Many2one("account.journal", "Payment Method", domain=[("type", "in", ("bank", "cash"))])

    def create_ir_loging(self,message,path,func):
        self.env["ir.logging"].sudo().create(
            {
                "name": message,
                "type": "server",
                "dbname": self.env.cr.dbname,
                "message": message,
                "path": path,
                "func": func,
                "line": 1,
            })
        
        
    @api.model
    def create(self, vals):
        vals.update({'name': self.env['ir.sequence'].next_by_code('sequence.quotation.order') or _('New')})
        _logger.info(self.env.user.name + " "+ "Create Quotation: %s", vals.get('name'))
        self.create_ir_loging(message=("Create Quotation:", vals.get('name')),path=self._name,func='create')
        res = super(SaleOrder, self).create(vals)
        return res

    def write(self,vals):
        if vals.get('name'):
            _logger.info(self.env.user.name +" "+ ": Origin sale order: %s,Change sale order :%s", self.name, vals.get('name'))
            self.create_ir_loging(
                message=("Origin sale order:",self.name,"-","Change name sale order:", vals.get('name'))
                ,path=self._name,func='write'
            )
        if vals.get('order_line', False) and self.state in ('confirm'):
            self.custom_create_revision()
        # if vals.get('state', False):
        #     so_name_before = self.name
        #     if vals.get('state') in ['confirm'] and vals.get('state') != self.state:
        #         vals.update({'name': so_name_before.replace('QT','PI')})
        return super(SaleOrder, self).write(vals)

    def unlink(self):
        for rec in self:
            _logger.info(rec.env.user.name +" "+"Delete sale order: %s", rec.name)
            rec.create_ir_loging(
                message=("Delete sale order:", rec.name)
                ,path=rec._name,func='unlink'
            )
        return super().unlink()

    def _action_cancel(self):
        res = super(SaleOrder, self)._action_cancel()
        _logger.info(self.env.user.name +" "+"cancel: %s", self.name)
        self.create_ir_loging(
            message=("Cancel:", self.name),
            path=self._name,
            func='_action_cancel'
        )
        return res
        

    def _prepare_confirmation_values(self):
        res = super(SaleOrder, self)._prepare_confirmation_values()
        if not self.is_order_confirm:
            res['name'] = self.env['ir.sequence'].next_by_code('sequence.sale.order')
            _logger.info(self.env.user.name +" "+"confirm sale order: %s",res['name'])
            self.create_ir_loging(
                message=("Name sale order when confirm:",res['name'])
                ,path=self._name,func='_prepare_confirmation_values'
            )
        else:
            _logger.info(self.env.user.name +" "+"confirm sale order: %s",self.name)
            self.create_ir_loging(
                message=("Name sale order when confirm:",self.name)
                ,path=self._name,func='_prepare_confirmation_values'
            )
        return res

    def action_request(self):
        self.ensure_one()
        self.write(self._prepare_confirmation_values())
        self.order_line._action_launch_stock_rule()
        if not self.is_order_confirm:
            self.write({
                'is_order_confirm': True,
                'state': 'confirm',
            })
        # template_id = self.env.ref('odb_sale_management.order_confirmation_successful_mail')
        # template_id.send_mail(self.id, force_send=True)
        if self.env.user.has_group('sale.group_auto_done_setting'):
            self.action_done()

    @api.onchange('partner_id')
    def onchange_partner_style(self):
        """ @onchage method to assign style to a document based on chosen partner"""
        # self.write({
        #     'style': self.partner_id.style or self.env.user.company_id.df_style or self.env.ref('odb_base.df_style_for_all_reports').id,
        #     'note': self.partner_id.invoice_terms
        # })
        return {'domain': {'bank_id': [('id', 'in', self.partner_id.bank_ids.bank_id.ids)] } }

    @api.depends("currency_id", "company_id", "amount_total", "partner_id")
    def _compute_num2words(self):
        for rec in self:
            amount_words = _('Disabled')
            # style = rec.style or rec.partner_id.style or rec.env.user.company_id.df_style or rec.env.ref('odb_base.df_style_for_all_reports')
            style = rec or rec.partner_id or rec.env.user.company_id # or rec.env.ref('odb_base.df_style_for_all_reports')
            if style:
                try:
                    amount_words = (num2words(rec.amount_total, lang=rec.partner_id.lang or 'en') + ' ' + (rec.currency_id.name or '')).upper()
                except NotImplementedError:
                    amount_words = (num2words(rec.amount_total, lang='en') + ' ' + (rec.currency_id.name or '')).upper()
            rec.write({'amount_words': amount_words})

    @api.onchange("commitment_date")
    def _onchange_commitment_date(self):
        """Update order lines with commitment date from sale order"""
        result = super(SaleOrder, self)._onchange_commitment_date() or {}
        if "warning" not in result:
            result["value"] = {
                "order_line": [
                    (1, line.id, {"commitment_date": self.commitment_date})
                    for line in self.order_line
                    if not line.commitment_date
                    or (
                        self.expected_date and line.commitment_date < self.expected_date
                    )
                ]
            }
        return result

    def action_split_order(self):
        wz_form = self.env.ref('odb_sale_management.wizard_split_order_form')
        wz_sale_id = self.env['wizard.split.sale.order'].create({
            'sale_id': self.id,
            'commitment_date': self.commitment_date,
        })
        wz_order_line_ids = []
        for line in self.order_line:
            vals = {
                'so_line_id': line.id,
                'product_id': line.product_id.id,
                'description': line.name,
                'product_uom_qty': line.product_uom_qty,
                'product_uom': line.product_uom.id,
                'partner_id': line.order_id.partner_id.id,
                'wz_sale_id': wz_sale_id.id,
                'selected_field': True,
            }
            wz_order_line_id = self.env['wizard.split.sale.order.line'].create(vals)
            wz_order_line_ids.append(wz_order_line_id.id)

        if wz_form:
            return {
                'name': 'Select PR Line To Split New PR',
                'type': 'ir.actions.act_window',
                'view_type': 'form',
                'view_mode': 'form',
                'res_model': 'wizard.split.sale.order',
                'views': [(wz_form.id, 'form')],
                'view_id': wz_form.id,
                'target': 'new',
                'context': {
                    'default_active': True,
                    'default_sale_id': wz_sale_id.sale_id.id,
                    'default_wz_order_line_ids': wz_order_line_ids,
                },
            }

    def email_remainder_quotation_due_date(self):
        sale_ids = self.env['sale.order'].search([])
        if sale_ids:
            for order in sale_ids:
                email_to = []
                for follower in order.message_follower_ids:
                    email_to.append(follower.partner_id.id)
                if not isinstance(order.validity_date, bool):
                    due_date = order.validity_date - timedelta(days=2)
                    if order.validity_date == datetime.now().date():
                        template_id = self.env['ir.model.data'].get_object_reference('odb_sale_management', 'sale_due_remainder_email_template')[1]
                        template_browse = self.env['mail.template'].browse(template_id)
                        due_date = order.validity_date
                        if template_browse:
                            values = template_browse.generate_email(order.id, ['subject', 'body_html', 'email_from', 'email_to', 'partner_to', 'email_cc', 'reply_to', 'scheduled_date'])
                            values['subject'] = "Reminder about " + order.name + " due on " + str(due_date)
                            values['email_from'] = self.env['res.users'].browse(self.env['res.users']._context['uid']).partner_id.email
                            values['res_id'] = False
                            values['author_id'] = self.env['res.users'].browse(self.env['res.users']._context['uid']).partner_id.id
                            values['recipient_ids'] = [(6, 0, email_to)]
                            if not values['email_to'] and not values['email_from']:
                                pass

                            msg_id = self.env['mail.mail'].create({
                                'body_html': values['body_html'],
                                'subject': values['subject'],
                                'email_to': values['email_to'],
                                'auto_delete': True,
                                'email_from': values['email_from'],
                                'references': values['mail_server_id'], })
                            mail_mail_obj = self.env['mail.mail']
                            if msg_id:
                                mail_mail_obj.sudo().send(msg_id)

                    elif datetime.now().date() == due_date:
                        template_id = self.env['ir.model.data'].get_object_reference('odb_sale_management', 'sale_before_due_remainder_email_template')[1]
                        template_browse = self.env['mail.template'].browse(template_id)
                        due_date = order.validity_date
                        if template_browse:
                            values = template_browse.generate_email(order.id, fields=None)
                            values['subject'] = "Reminder about " + order.name + " due on " + str(due_date)
                            values['email_from'] = self.env['res.users'].browse(self.env['res.users']._context['uid']).partner_id.email
                            values['res_id'] = False
                            values['author_id'] = self.env['res.users'].browse(self.env['res.users']._context['uid']).partner_id.id
                            values['recipient_ids'] = [(6, 0, email_to)]
                            if not values['email_to'] and not values['email_from']:
                                pass
                            msg_id = self.env['mail.mail'].create({
                                'body_html': values['body_html'],
                                'subject': values['subject'],
                                'email_to': values['email_to'],
                                'auto_delete': True,
                                'email_from': values['email_from'],
                                'references': values['mail_server_id'], })
                            mail_mail_obj = self.env['mail.mail']
                            if msg_id:
                                mail_mail_obj.sudo().send(msg_id)
                    else:
                        pass
            return True

    def make_order_revision(self):
        for rec in self:
            vals = {'custom_counter': rec.custom_counter + 1}
            revised_vals = {'revised_number': rec.custom_store_name, 'sale_order_id': rec.id}
            if rec.custom_counter == 0:
                vals.update({'custom_store_name': rec.name})
                revised_vals.update({'revised_number': rec.name})
            if vals.get('custom_counter') > 1:
                vals.update({'name' : rec.custom_store_name + '-R'+ str(rec.custom_counter)})
                revised_vals.update({'revised_number': rec.custom_store_name + '-R'+ str(rec.custom_counter)})

            revised_obj = self.env['quotation.history'].sudo().create(revised_vals)
            for line in rec.order_line:
                reline_vals = {
                    'product_id_rev': line.product_id.id,
                    # 'layout_category_id_rev' : line.layout_category_id.id, #  'sale.order.line' object has no attribute 'layout_category_id' in odoo12
                    'name_rev' : line.name,
                    'qty_rev' : line.product_uom_qty,
                    'uom_rev' : line.product_uom.id, 
                    'price_rev' : line.price_unit,
                    'discount_rev' : line.discount,
                    'subtotal_rev' : line.price_subtotal,
                    'total_rev' : line.price_total, 
                    'line_custom_id': revised_obj.id,
                 }
                self.env['quotation.history.line'].sudo().create(reline_vals)

            rec.write(vals)
        return True

    def show_revisedline(self):
        rline = []
        for rec in self:
            for order in rec.revised_custom_ids:
                for line in order.revised_line_ids:
                    rline.append(line.id)
            res = self.env.ref('odb_sale_management.action_view_quotation_history_line')
            res = res.read()[0]
            res['domain'] = str([('id','in',rline)])
        return res

    def action_sale_order_history(self):
        return {
            'name': _("Quotations and Sales"),
            'type': 'ir.actions.act_window',
            'res_model': 'sale.order',
            'view_mode': 'tree,form,graph',
            'view_type': 'form',
            # 'group_ids':
            'views': [[False, 'tree'],[False, 'form'],],
            'context': {'search_default_partner_id': self.partner_id.id,'default_partner_id': self.partner_id.id},
            'target': 'current',
        }

    @api.returns('self', lambda value: value.id)
    def copy(self, default=None):
        if not default:
            default = {}
        default.update({'commitment_date': datetime.now() + timedelta(days=7)})
        return super(SaleOrder, self).copy(default)
    
    def button_confirm_sale_order(self):
        for rec in self:
            rec.action_request()

    def fields_view_get(self, view_id=None, view_type='list', toolbar=False,submenu=False):
        res = super(SaleOrder, self).fields_view_get(
            view_id=view_id, view_type=view_type, toolbar=toolbar,submenu=submenu) 

        if not self._context.get('search_default_my_quotation', False):
            button_action_confirm = self.env.ref('odb_sale_management.model_sale_order_action_cofirm').id or False
            for button in res.get('toolbar', {}).get('action', []):
                if button_action_confirm and button['id'] == button_action_confirm:
                    res['toolbar']['action'].remove(button) 
        return res

    def action_quotation_send(self):
        res = super(SaleOrder, self).action_quotation_send()
        excel_template_id = self.env.ref('odb_sale_management.get_list_sale_order_xlsx').sudo()._render_xlsx(self.ids,[])
        data_record = base64.b64encode(excel_template_id[0])
        file_name = 'R' + self.name + '.xlsx'
        ir_values = {
            'name': file_name,
            'type': 'binary',
            'datas': data_record,
            'store_fname': file_name,
            'res_model': 'purchase.order',
            'mimetype': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        }
        excel_attachment = self.env['ir.attachment'].create(ir_values)
        template = self.env['mail.template'].browse(res.get('context').get('default_template_id'))
        template.attachment_ids = False
        template.attachment_ids = [(4, excel_attachment.id)]
        return res

    def wizards_open_import_sol(self):
        view = self.env.ref('odb_sale_management.wizard_import_sale_line')
        context={'order':self.id,'import_type':'sale_line'}
        return {
            'name': 'Wizards Import Sale Order Line',
            'type': 'ir.actions.act_window',
            'view_type': 'form',
            'view_mode': 'form',
            'res_model': 'wizard.import.sale.order',
            'views': [(view.id, 'form')],
            'view_id': view.id,
            'target': 'new',
            'context': context,
        }
